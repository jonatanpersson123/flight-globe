{"remainingRequest":"/Users/jonatanpersson/Documents/jp/repos/flyer-globe/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/jonatanpersson/Documents/jp/repos/flyer-globe/src/components/Globe.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/jonatanpersson/Documents/jp/repos/flyer-globe/src/components/Globe.vue","mtime":1595704485804},{"path":"/Users/jonatanpersson/Documents/jp/repos/flyer-globe/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jonatanpersson/Documents/jp/repos/flyer-globe/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/jonatanpersson/Documents/jp/repos/flyer-globe/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jonatanpersson/Documents/jp/repos/flyer-globe/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJwppbXBvcnQgT3JiaXRDb250cm9scyBmcm9tICd0aHJlZS1vcmJpdGNvbnRyb2xzJwppbXBvcnQgU2VhSW1hZ2UgZnJvbSAnLi4vYXNzZXRzL3NlYS5qcGcnCmltcG9ydCBTdGFycyBmcm9tICcuLi9hc3NldHMvc3RhcnMucG5nJwppbXBvcnQgQ291bnRyaWVzIGZyb20gJy4uL2RhdGEvZ2xvYmUtY291bnRyaWVzJwppbXBvcnQgVGVzc2FsYXRvcjNEIGZyb20gJy4uL3V0aWxzL3Rlc3NhbGF0b3IzZCcKCmV4cG9ydCBkZWZhdWx0IHsKICAgIG5hbWU6ICdHbG9iZScsCiAgICBwcm9wczogW10sCiAgICBkYXRhOiAoKSA9PiAoewogICAgICAgIHJlbmRlcmVyOiBudWxsLAogICAgICAgIHNjZW5lOiBudWxsLAogICAgICAgIGNhbWVyYTogbnVsbCwKICAgICAgICBjb250cm9sczogbnVsbCwKICAgICAgICByYWRpdXM6IDAuOTk1LAogICAgICAgIHNlZ21lbnRzOiAzMiwKICAgICAgICBpbnRlcnNlY3RlZE9iamVjdDogbnVsbCwKICAgICAgICBob3ZlclNjYWxlOiAxLjAxLAogICAgICAgIGNvbnRpbmVudHM6IFsiRVUiLCAiQU4iLCAiQVMiLCAiT0MiLCAiU0EiLCAiQUYiLCAiTkEiXSwKICAgICAgICByZXN1bHRDb3VudHJpZXM6IFtdLAogICAgICAgIGdsb2JlQ291bnRyaWVzOiBbXQogICAgfSksCgogICAgbWV0aG9kczogewogICAgICAgIGluaXRHbG9iZSgpIHsKICAgICAgICAgICAgdGhpcy5zZXR1cFJlbmRlcmVyKCkKICAgICAgICAgICAgdGhpcy5zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpCiAgICAgICAgICAgIHRoaXMuc2V0dXBDYW1lcmEoKQogICAgICAgICAgICB0aGlzLnNldHVwTGlnaHRzKCkKCiAgICAgICAgICAgIHRoaXMuYmFzZUdsb2JlID0gbmV3IFRIUkVFLk9iamVjdDNEKCkKICAgICAgICAgICAgdGhpcy5iYXNlR2xvYmUuc2NhbGUuc2V0KDIwLCAyMCwgMjApCiAgICAgICAgICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMuYmFzZUdsb2JlKQoKICAgICAgICAgICAgY29uc3Qgc3RhcmZpZWxkID0gbmV3IFRIUkVFLk1lc2goCiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoOTAsIDY0LCA2NCksIAogICAgICAgICAgICAgICAgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsKICAgICAgICAgICAgICAgICAgICBtYXA6IFRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUoU3RhcnMpLCAKICAgICAgICAgICAgICAgICAgICBzaWRlOiBUSFJFRS5CYWNrU2lkZQogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgKQogICAgICAgICAgICB0aGlzLnNjZW5lLmFkZChzdGFyZmllbGQpCgogICAgICAgICAgICB0aGlzLnNldHVwVGV4dHVyZSgpCgogICAgICAgICAgICB0aGlzLnNldHVwQ29udHJvbHMoKQoKICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbkRvY3VtZW50TW91c2VNb3ZlLCBmYWxzZSkKICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLm9uTW91c2VLZXlVcCwgZmFsc2UpCiAgICAgICAgfSwKCiAgICAgICAgb25Eb2N1bWVudE1vdXNlTW92ZShldmVudCkgewogICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpCgogICAgICAgICAgICBjb25zdCBtb3VzZVggPSAoZXZlbnQuY2xpZW50WCAvIHdpbmRvdy5pbm5lcldpZHRoKSAqIDIgLSAxCiAgICAgICAgICAgIGNvbnN0IG1vdXNlWSA9IC0oZXZlbnQuY2xpZW50WSAvIHdpbmRvdy5pbm5lckhlaWdodCkgKiAyICsgMQogICAgICAgICAgICBjb25zdCB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMyhtb3VzZVgsIG1vdXNlWSwgLTEpCiAgICAgICAgICAgIHZlY3Rvci51bnByb2plY3QodGhpcy5jYW1lcmEpCgogICAgICAgICAgICBjb25zdCByYXljYXN0ZXIgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKHRoaXMuY2FtZXJhLnBvc2l0aW9uLCB2ZWN0b3Iuc3ViKHRoaXMuY2FtZXJhLnBvc2l0aW9uKS5ub3JtYWxpemUoKSkKICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0cyA9IHJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3QodGhpcy5iYXNlR2xvYmUsIHRydWUpCiAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzLmxlbmd0aCA+IDAgJiYgaW50ZXJzZWN0c1swXS5vYmplY3QubmFtZSA9PT0gImxhbmQiKSB7CiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzLmF1dG9Sb3RhdGUgPSBmYWxzZQogICAgICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3RlZE9iamVjdCA9IGludGVyc2VjdHNbMF0ub2JqZWN0CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdGVkT2JqZWN0ID0gbnVsbAogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgb25Nb3VzZUtleVVwKGV2ZW50KSB7CiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSA4MikgeyAvLyBrZXk6IFIKICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHMuYXV0b1JvdGF0ZSA9ICF0aGlzLmNvbnRyb2xzLmF1dG9Sb3RhdGUKICAgICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgCiAgICAgICAgc2V0dXBSZW5kZXJlcigpIHsKICAgICAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCkKICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4MDAwMDAwLCAwLjApCiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykKICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpCiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KQogICAgICAgIH0sCiAgICAgICAgCiAgICAgICAgc2V0dXBDYW1lcmEoKSB7CiAgICAgICAgICAgIHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDQ1LCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMC4wMSwgNDUwMCk7CiAgICAgICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnggPSAtMjIKICAgICAgICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24ueSA9IDEwCiAgICAgICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSAtNjQKICAgICAgICB9LAoKICAgICAgICBzZXR1cExpZ2h0cygpIHsKICAgICAgICAgICAgdGhpcy5zY2VuZS5hZGQobmV3IFRIUkVFLkFtYmllbnRMaWdodCgweDU1NTU1NSkpCiAgICAgICAgICAgIAogICAgICAgICAgICB2YXIgZGlyZWN0aW9uYWxMaWdodDEgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgweGFhYWFhYSwgMC41KTsKICAgICAgICAgICAgZGlyZWN0aW9uYWxMaWdodDEucG9zaXRpb24uc2V0KC0xLCAxLCAxKS5ub3JtYWxpemUoKTsKICAgICAgICAgICAgdGhpcy5zY2VuZS5hZGQoZGlyZWN0aW9uYWxMaWdodDEpOwoKICAgICAgICAgICAgdmFyIGRpcmVjdGlvbmFsTGlnaHQyID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoMHhhYWFhYWEsIDAuNSk7CiAgICAgICAgICAgIGRpcmVjdGlvbmFsTGlnaHQyLnBvc2l0aW9uLnNldCgtMSwgMSwgLTEpLm5vcm1hbGl6ZSgpOwogICAgICAgICAgICB0aGlzLnNjZW5lLmFkZChkaXJlY3Rpb25hbExpZ2h0Mik7CgogICAgICAgICAgICB2YXIgZGlyZWN0aW9uYWxMaWdodDMgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgweGFhYWFhYSwgMC41KTsKICAgICAgICAgICAgZGlyZWN0aW9uYWxMaWdodDMucG9zaXRpb24uc2V0KDEsIDEsIC0xKS5ub3JtYWxpemUoKTsKICAgICAgICAgICAgdGhpcy5zY2VuZS5hZGQoZGlyZWN0aW9uYWxMaWdodDMpOwoKICAgICAgICAgICAgdmFyIGRpcmVjdGlvbmFsTGlnaHQ0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoMHhhYWFhYWEsIDAuNSk7CiAgICAgICAgICAgIGRpcmVjdGlvbmFsTGlnaHQ0LnBvc2l0aW9uLnNldCgxLCAxLCAxKS5ub3JtYWxpemUoKTsKICAgICAgICAgICAgdGhpcy5zY2VuZS5hZGQoZGlyZWN0aW9uYWxMaWdodDQpOwogICAgICAgIH0sCgogICAgICAgIHNldHVwVGV4dHVyZSgpIHsKICAgICAgICAgICAgY29uc3Qgc2VhVGV4dHVyZSA9IFRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUoU2VhSW1hZ2UsIFRIUkVFLlVWTWFwcGluZywgKCkgPT4gewogICAgICAgICAgICAgICAgc2VhVGV4dHVyZS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nCiAgICAgICAgICAgICAgICBzZWFUZXh0dXJlLndyYXBUID0gVEhSRUUuUmVwZWF0V3JhcHBpbmcKICAgICAgICAgICAgICAgIHNlYVRleHR1cmUucmVwZWF0LnNldCgxNiwgOCkKICAgICAgICAgICAgICAgIHRoaXMuYmFzZUdsb2JlLmFkZChuZXcgVEhSRUUuTWVzaCgKICAgICAgICAgICAgICAgICAgICBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkodGhpcy5yYWRpdXMsIHRoaXMuc2VnbWVudHMsIHRoaXMuc2VnbWVudHMpLAogICAgICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKHsKICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsCiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoVGVzdDogdHJ1ZSwKICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGhXcml0ZTogZmFsc2UsCiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuOTUsCiAgICAgICAgICAgICAgICAgICAgICAgIG1hcDogc2VhVGV4dHVyZSwKICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IDB4NjY5OWZmCiAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgICkpCiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUNvdW50cmllcygpCiAgICAgICAgICAgIH0pCiAgICAgICAgfSwKCiAgICAgICAgc2V0dXBDb250cm9scygpIHsKICAgICAgICAgICAgdGhpcy5jb250cm9scyA9IG5ldyBPcmJpdENvbnRyb2xzKCB0aGlzLmNhbWVyYSwgdGhpcy5yZW5kZXJlci5kb21FbGVtZW50ICkKICAgICAgICAgICAgdGhpcy5jb250cm9scy5yb3RhdGVTcGVlZCA9IDAuNDU7CiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuem9vbVNwZWVkID0gMC4yMDsKICAgICAgICAgICAgdGhpcy5jb250cm9scy5taW5EaXN0YW5jZSA9IDIwLjA7CiAgICAgICAgICAgIHRoaXMuY29udHJvbHMubWF4RGlzdGFuY2UgPSAxMDAuMDsKICAgICAgICAgICAgdGhpcy5jb250cm9scy5keW5hbWljRGFtcGluZ0ZhY3RvciA9IDAuMQogICAgICAgICAgICB0aGlzLmNvbnRyb2xzLmF1dG9Sb3RhdGVTcGVlZCA9IDEuMDsKICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzLmF1dG9Sb3RhdGUgPSB0cnVlCiAgICAgICAgICAgIH0sIDMwMDApCiAgICAgICAgfSwKCiAgICAgICAgZ2V0Q29sb3JCYXNlZE9uQ29udGllbnQoY291bnRyeUNvZGUpIHsKICAgICAgICAgICAgbGV0IGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKDB4ZmYwMDAwKQogICAgICAgICAgICBjb25zdCBjb3VudHJ5ID0gdGhpcy5nbG9iZUNvdW50cmllcy5maW5kKGNvdW50cnkgPT4gY291bnRyeS5kYXRhLmNvZGUgPT09IGNvdW50cnlDb2RlKQogICAgICAgICAgICBsZXQgY29udGllbnRJbmRleCA9IGNvdW50cnkgPyB0aGlzLmNvbnRpbmVudHMuaW5kZXhPZihjb3VudHJ5LmRhdGEuY29udCkgOiAtMQogICAgICAgICAgICBpZighY291bnRyeSkgewogICAgICAgICAgICAgICAgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoMHgwMDAwMDApCiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnY291bGQgbm90IGZvdW5kIG1hdGNoaW5nIGNvdW50cnknLCBjb3VudHJ5Q29kZSkKICAgICAgICAgICAgfSBlbHNlIGlmIChjb250aWVudEluZGV4ICE9PSAtMSkgewogICAgICAgICAgICAgICAgLy8gVGVtcCBmaXggZm9yIG5vdCB1c2luZyBncmVlbiBjb2xvcnMgb24gY29udGllbnRzCiAgICAgICAgICAgICAgICAvLyBUT0RPIC0gbWFrZSBjb2xvciBtYXRyaXggZm9yIGNvbnRpbmVudHMKICAgICAgICAgICAgICAgIGNvbnRpZW50SW5kZXggPSBjb250aWVudEluZGV4ID09PSAyID8gNCA6IGNvbnRpZW50SW5kZXgKICAgICAgICAgICAgICAgIGNvbG9yLnNldEhTTCgKICAgICAgICAgICAgICAgICAgICBjb250aWVudEluZGV4ICogKDEgLyA3KSwKICAgICAgICAgICAgICAgICAgICBNYXRoLnJhbmRvbSgpICogMC4yNSArIDAuNjUsCiAgICAgICAgICAgICAgICAgICAgTWF0aC5yYW5kb20oKSAvIDIgKyAwLjI1CiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGNvbG9yCiAgICAgICAgfSwKCiAgICAgICAgY3JlYXRlQ291bnRyaWVzKCkgewogICAgICAgICAgICB0aGlzLmdsb2JlQ291bnRyaWVzLmZvckVhY2goY291bnRyeSA9PiB7CiAgICAgICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBUZXNzYWxhdG9yM0QoY291bnRyeSwgMCkKCiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMuZ2V0Q29sb3JCYXNlZE9uQ29udGllbnQoY291bnRyeS5kYXRhLmNvZGUpCgogICAgICAgICAgICAgICAgY29uc3QgbWVzaCA9IGNvdW50cnkubWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCh7CiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yCiAgICAgICAgICAgICAgICB9KSkKICAgICAgICAgICAgICAgIG1lc2gubmFtZSA9ICJsYW5kIjsKICAgICAgICAgICAgICAgIG1lc2gudXNlckRhdGEuY291bnRyeSA9IGNvdW50cnkuZGF0YS5uYW1lCiAgICAgICAgICAgICAgICBtZXNoLnVzZXJEYXRhLmNvZGUgPSBjb3VudHJ5LmRhdGEuY29kZQogICAgICAgICAgICAgICAgdGhpcy5iYXNlR2xvYmUuYWRkKG1lc2gpCiAgICAgICAgICAgIH0pCiAgICAgICAgfSwKCiAgICAgICAgYW5pbWF0ZSgpIHsKICAgICAgICAgICAgY29uc3QgYW5pbWF0ZSA9ICgpID0+IHsKICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKQogICAgICAgICAgICAgICAgdGhpcy5jb250cm9scy51cGRhdGUoKQogICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgYW5pbWF0ZSgpCiAgICAgICAgfQogICAgfSwKCiAgICB3YXRjaDogewogICAgICAgIGludGVyc2VjdGVkT2JqZWN0OiBmdW5jdGlvbihuZXdWYWwsIG9sZFZhbCkgIHsKICAgICAgICAgICAgaWYobmV3VmFsICE9PSBvbGRWYWwpIHsKICAgICAgICAgICAgICAgIGlmKG9sZFZhbCAhPSBudWxsKSB7CiAgICAgICAgICAgICAgICAgICAgb2xkVmFsLnNjYWxlLnNldCgxLjAsIDEuMCwgMS4wKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYobmV3VmFsICE9IG51bGwpIHsKICAgICAgICAgICAgICAgICAgICBuZXdWYWwuc2NhbGUuc2V0KHRoaXMuaG92ZXJTY2FsZSwgMS4wMSwgMS4wMSkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ29uQ291bnRyeUNoYW5nZScsIG5ld1ZhbCAhPSBudWxsID8gbmV3VmFsLnVzZXJEYXRhLmNvdW50cnkgOiAnJykKICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH0sCgogICAgbW91bnRlZCgpIHsKICAgICAgICB0aGlzLmdsb2JlQ291bnRyaWVzID0gT2JqZWN0LmtleXMoQ291bnRyaWVzKS5yZWR1Y2UoZnVuY3Rpb24ocmVzdWx0LCBjb3VudHJ5KSB7CiAgICAgICAgICAgIHZhciBpdGVtID0gQ291bnRyaWVzW2NvdW50cnldCiAgICAgICAgICAgIGl0ZW0uZGF0YS5uYW1lID0gY291bnRyeTsKICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSkKICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9LCBbXSkKICAgICAgICB0aGlzLmluaXRHbG9iZSgpCiAgICAgICAgdGhpcy5hbmltYXRlKCkKICAgIH0KfQo="},{"version":3,"sources":["Globe.vue"],"names":[],"mappings":";;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Globe.vue","sourceRoot":"src/components","sourcesContent":["<template>\n    <div id=\"globe\"></div>\n</template>\n\n<script>\nimport * as THREE from 'three'\nimport OrbitControls from 'three-orbitcontrols'\nimport SeaImage from '../assets/sea.jpg'\nimport Stars from '../assets/stars.png'\nimport Countries from '../data/globe-countries'\nimport Tessalator3D from '../utils/tessalator3d'\n\nexport default {\n    name: 'Globe',\n    props: [],\n    data: () => ({\n        renderer: null,\n        scene: null,\n        camera: null,\n        controls: null,\n        radius: 0.995,\n        segments: 32,\n        intersectedObject: null,\n        hoverScale: 1.01,\n        continents: [\"EU\", \"AN\", \"AS\", \"OC\", \"SA\", \"AF\", \"NA\"],\n        resultCountries: [],\n        globeCountries: []\n    }),\n\n    methods: {\n        initGlobe() {\n            this.setupRenderer()\n            this.scene = new THREE.Scene()\n            this.setupCamera()\n            this.setupLights()\n\n            this.baseGlobe = new THREE.Object3D()\n            this.baseGlobe.scale.set(20, 20, 20)\n            this.scene.add(this.baseGlobe)\n\n            const starfield = new THREE.Mesh(\n                new THREE.SphereGeometry(90, 64, 64), \n                new THREE.MeshBasicMaterial({\n                    map: THREE.ImageUtils.loadTexture(Stars), \n                    side: THREE.BackSide\n                })\n            )\n            this.scene.add(starfield)\n\n            this.setupTexture()\n\n            this.setupControls()\n\n            document.addEventListener('mousemove', this.onDocumentMouseMove, false)\n            document.addEventListener('keyup', this.onMouseKeyUp, false)\n        },\n\n        onDocumentMouseMove(event) {\n            event.preventDefault()\n\n            const mouseX = (event.clientX / window.innerWidth) * 2 - 1\n            const mouseY = -(event.clientY / window.innerHeight) * 2 + 1\n            const vector = new THREE.Vector3(mouseX, mouseY, -1)\n            vector.unproject(this.camera)\n\n            const raycaster = new THREE.Raycaster(this.camera.position, vector.sub(this.camera.position).normalize())\n            const intersects = raycaster.intersectObject(this.baseGlobe, true)\n            if (intersects.length > 0 && intersects[0].object.name === \"land\") {\n                this.controls.autoRotate = false\n                this.intersectedObject = intersects[0].object\n            } else {\n                this.intersectedObject = null\n            }\n        },\n\n        onMouseKeyUp(event) {\n            if (event.keyCode === 82) { // key: R\n                this.controls.autoRotate = !this.controls.autoRotate\n            }\n        },\n        \n        setupRenderer() {\n            this.renderer = new THREE.WebGLRenderer()\n            this.renderer.setClearColor(0x000000, 0.0)\n            this.renderer.setPixelRatio(window.devicePixelRatio)\n            this.renderer.setSize(window.innerWidth, window.innerHeight)\n            document.body.appendChild(this.renderer.domElement)\n        },\n        \n        setupCamera() {\n            this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 4500);\n            this.camera.position.x = -22\n            this.camera.position.y = 10\n            this.camera.position.z = -64\n        },\n\n        setupLights() {\n            this.scene.add(new THREE.AmbientLight(0x555555))\n            \n            var directionalLight1 = new THREE.DirectionalLight(0xaaaaaa, 0.5);\n            directionalLight1.position.set(-1, 1, 1).normalize();\n            this.scene.add(directionalLight1);\n\n            var directionalLight2 = new THREE.DirectionalLight(0xaaaaaa, 0.5);\n            directionalLight2.position.set(-1, 1, -1).normalize();\n            this.scene.add(directionalLight2);\n\n            var directionalLight3 = new THREE.DirectionalLight(0xaaaaaa, 0.5);\n            directionalLight3.position.set(1, 1, -1).normalize();\n            this.scene.add(directionalLight3);\n\n            var directionalLight4 = new THREE.DirectionalLight(0xaaaaaa, 0.5);\n            directionalLight4.position.set(1, 1, 1).normalize();\n            this.scene.add(directionalLight4);\n        },\n\n        setupTexture() {\n            const seaTexture = THREE.ImageUtils.loadTexture(SeaImage, THREE.UVMapping, () => {\n                seaTexture.wrapS = THREE.RepeatWrapping\n                seaTexture.wrapT = THREE.RepeatWrapping\n                seaTexture.repeat.set(16, 8)\n                this.baseGlobe.add(new THREE.Mesh(\n                    new THREE.SphereGeometry(this.radius, this.segments, this.segments),\n                    new THREE.MeshLambertMaterial({\n                        transparent: true,\n                        depthTest: true,\n                        depthWrite: false,\n                        opacity: 0.95,\n                        map: seaTexture,\n                        color: 0x6699ff\n                    })\n                ))\n                this.createCountries()\n            })\n        },\n\n        setupControls() {\n            this.controls = new OrbitControls( this.camera, this.renderer.domElement )\n            this.controls.rotateSpeed = 0.45;\n            this.controls.zoomSpeed = 0.20;\n            this.controls.minDistance = 20.0;\n            this.controls.maxDistance = 100.0;\n            this.controls.dynamicDampingFactor = 0.1\n            this.controls.autoRotateSpeed = 1.0;\n            setTimeout(() => {\n                this.controls.autoRotate = true\n            }, 3000)\n        },\n\n        getColorBasedOnContient(countryCode) {\n            let color = new THREE.Color(0xff0000)\n            const country = this.globeCountries.find(country => country.data.code === countryCode)\n            let contientIndex = country ? this.continents.indexOf(country.data.cont) : -1\n            if(!country) {\n                color = new THREE.Color(0x000000)\n                console.log('could not found matching country', countryCode)\n            } else if (contientIndex !== -1) {\n                // Temp fix for not using green colors on contients\n                // TODO - make color matrix for continents\n                contientIndex = contientIndex === 2 ? 4 : contientIndex\n                color.setHSL(\n                    contientIndex * (1 / 7),\n                    Math.random() * 0.25 + 0.65,\n                    Math.random() / 2 + 0.25\n                )\n            }\n            return color\n        },\n\n        createCountries() {\n            this.globeCountries.forEach(country => {\n                const geometry = new Tessalator3D(country, 0)\n\n                const color = this.getColorBasedOnContient(country.data.code)\n\n                const mesh = country.mesh = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({\n                    color: color\n                }))\n                mesh.name = \"land\";\n                mesh.userData.country = country.data.name\n                mesh.userData.code = country.data.code\n                this.baseGlobe.add(mesh)\n            })\n        },\n\n        animate() {\n            const animate = () => {\n                requestAnimationFrame(animate)\n                this.controls.update()\n                this.renderer.render(this.scene, this.camera)\n            }\n            animate()\n        }\n    },\n\n    watch: {\n        intersectedObject: function(newVal, oldVal)  {\n            if(newVal !== oldVal) {\n                if(oldVal != null) {\n                    oldVal.scale.set(1.0, 1.0, 1.0)\n                }\n                if(newVal != null) {\n                    newVal.scale.set(this.hoverScale, 1.01, 1.01)\n                }\n                this.$emit('onCountryChange', newVal != null ? newVal.userData.country : '')\n            }\n        }\n    },\n\n    mounted() {\n        this.globeCountries = Object.keys(Countries).reduce(function(result, country) {\n            var item = Countries[country]\n            item.data.name = country;\n            result.push(item)\n            return result;\n        }, [])\n        this.initGlobe()\n        this.animate()\n    }\n}\n</script>\n\n<style scoped>\n</style>\n"]}]}